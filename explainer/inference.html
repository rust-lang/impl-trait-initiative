<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Appendix A: Inference details - Impl trait initiative</title>
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item "><a href="../index.html">üëã Welcome</a></li><li class="chapter-item "><a href="../CHARTER.html">üìú Charter</a></li><li class="chapter-item "><a href="../updates.html">‚úèÔ∏è Updates</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../updates/2021-oct.html">2021-Oct</a></li></ol></li><li class="chapter-item "><a href="../evaluation.html">üî¨ Evaluation</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../evaluation/apit-and-turbofish.html">APIT and Turbofish</a></li></ol></li><li class="chapter-item expanded "><a href="../explainer.html">üìö Explainer</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../explainer/apit.html">Impl trait in argument types</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../explainer/apit_turbofish.html">Turbofish</a></li><li class="chapter-item "><a href="../explainer/apit_traits.html">Traits and impls</a></li></ol></li><li class="chapter-item "><a href="../explainer/tait.html">Impl trait in type aliases</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../explainer/tait_infer.html">Inferring the hidden type</a></li><li class="chapter-item "><a href="../explainer/tait_ref.html">Referencing from outside the module</a></li><li class="chapter-item "><a href="../explainer/tait_generics.html">Generic parameters</a></li></ol></li><li class="chapter-item "><a href="../explainer/rpit.html">Impl trait in return types</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../explainer/rpit_capture.html">Generic parameter capture</a></li><li class="chapter-item "><a href="../explainer/rpit_names.html">Naming impl trait in return types</a></li></ol></li><li class="chapter-item "><a href="../explainer/rpit_trait.html">Return types in trait definitions</a></li><li class="chapter-item "><a href="../explainer/lbit.html">Impl trait in let bindings</a></li><li class="chapter-item "><a href="../explainer/auto_trait.html">Auto traits and impl trait</a></li><li class="chapter-item expanded "><a href="../explainer/inference.html" class="active">Appendix A: Inference details</a></li><li class="chapter-item "><a href="../explainer/where_ok.html">Appendix B: Where can impl trait be used</a></li><li class="chapter-item "><a href="../explainer/where_not_ok.html">Appendix C: Where can impl trait NOT be used</a></li><li class="chapter-item "><a href="../explainer/glossary.html">Appendix D: Glossary</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../explainer/glossary/defining_scope.html">Defining scope</a></li><li class="chapter-item "><a href="../explainer/glossary/hidden_type.html">Hidden type</a></li><li class="chapter-item "><a href="../explainer/glossary/input_impl_trait.html">Input impl trait</a></li><li class="chapter-item "><a href="../explainer/glossary/output_impl_trait.html">Output impl trait</a></li></ol></li></ol></li><li class="chapter-item "><a href="../RFC.html">‚ú® RFCs</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="../RFCs/rpit-in-traits.html">Return position impl Trait in traits</a></li><li class="chapter-item "><a href="../RFCs/named-function-types.html">Function types and impl trait</a></li></ol></li><li class="chapter-item "><a href="../FAQ.html">üòï FAQ</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Impl trait initiative</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/rust-lang/impl-trait" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="appendix-a-inference-details"><a class="header" href="#appendix-a-inference-details">Appendix A: Inference details</a></h1>
<p><img src="https://img.shields.io/badge/status-nightly-important" alt="nightly" /></p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>The process to infer the hidden type for an impl Trait is as follows.</p>
<ul>
<li>When type-checking functions or code within the <em>defining scope</em> of an impl Trait <code>X</code>:
<ul>
<li>Accumulate subtyping constraints from type check:
<ul>
<li>For example, <code>let var: X = 22_i32</code> would create the subtyping constraint that <code>i32</code> is a subtype of <code>X</code>.</li>
<li>Similarly, given <code>fn foo() -&gt; X</code>, <code>let var: i32 = foo()</code> wold create the subtyping constraint that <code>X</code> be a subtype of <code>i32</code>.</li>
</ul>
</li>
<li>The type <code>X</code> is assumed to implement the traits that appear in its bounds
<ul>
<li>Exception: auto traits. Proving an auto trait <code>X: Send</code> is done by &quot;revealing&quot; the hidden type and proving the auto trait against the hidden type.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="terminology-opaque-type"><a class="header" href="#terminology-opaque-type">Terminology: Opaque type</a></h2>
<p>An impl trait in <a href="../glossary/output_impl_trait.html">output position</a> is called an <strong>opaque type</strong>. We write the opaque type as <code>O&lt;P0...Pn&gt;</code>, where <code>P0...Pn</code> are the generic types on the opaque type. For a <a href="./tait.html">type alias impl trait</a>, the generic types are the generics from the type alias. For a <a href="./rpit.html">return position impl trait</a>, the generics are defined by the <a href="./rpit_capture.html">RPIT capture rules</a>.</p>
<h2 id="terminology-opaque-type-bounds"><a class="header" href="#terminology-opaque-type-bounds">Terminology: Opaque type bounds</a></h2>
<p>Given an opaque type <code>O&lt;P1...Pn&gt;</code>, let <code>B1..Bn</code> be the <em>bounds</em> on that opaque type, appropriately substituted for <code>P1..Pn</code>. For example, if the user wrote <code>type Foo&lt;T&gt; = impl PartialEq&lt;T&gt; + Debug + 'static</code> and we have the opaque type <code>Foo&lt;u32&gt;</code>, then the bounds would be <code>PartialEq&lt;u32&gt;</code>, <code>Debug</code>, and <code>'static</code>.</p>
<h2 id="notation-applying-bounds-to-a-type-to-create-a-where-clause"><a class="header" href="#notation-applying-bounds-to-a-type-to-create-a-where-clause">Notation: applying bounds to a type to create a where clause</a></h2>
<p>Given a type <code>T</code> and an opaque type bound <code>B1</code>, we write <code>T: B1</code> to signify the where clause that results from using <code>T</code> as the &quot;self type&quot; for the bound <code>B1</code>. For example, given the type <code>i32</code> and the bound <code>PartialEq&lt;u32&gt;</code>, the where clause would be <code>i32: PartialEq&lt;u32&gt;</code> Given the type <code>i32</code> and the bound <code>'static</code>, the where clause would be <code>i32: 'static</code>.</p>
<h2 id="type-checking-opaque-types"><a class="header" href="#type-checking-opaque-types">Type checking opaque types</a></h2>
<p>The following section describes how to type check functions or other pieces of code that reference opaque types.</p>
<h3 id="rules-that-always-apply"><a class="header" href="#rules-that-always-apply">Rules that always apply</a></h3>
<p>The following rules for type-checking opaque types apply to all code, whether or not it is part of the type's defining scope.</p>
<h4 id="reflexive-equality-for-opaque-types"><a class="header" href="#reflexive-equality-for-opaque-types">Reflexive equality for opaque types</a></h4>
<p>Like any type, an opaque type <code>O&lt;P0...Pn&gt;</code> can be judged to be equal to itself. This does not require knowing the hidden type.</p>
<p><strong>Example.</strong> The following program <strong>compiles</strong> because of this rule.</p>
<pre><pre class="playground"><code class="language-rust">mod foo {
    type Foo = impl Clone;

    fn make_foo(x: u32) -&gt; Foo {
        x
    }
}

fn main() {
    let mut x: Foo = make_foo(22);

    // Requires knowing that `Foo = Foo`.
    x = make_foo(44);
}
</code></pre></pre>
<p><strong>Example.</strong> The following program <strong>does not compile</strong> even though the hidden types are the same.</p>
<pre><pre class="playground"><code class="language-rust">mod foo {
    type Foo&lt;T&gt; = impl Clone;

    fn make_foo&lt;A&gt;(x: u32) -&gt; Foo&lt;A&gt; {
        x
    }
}

fn main() {
    let mut x: Foo&lt;String&gt; = make_foo::&lt;String&gt;(22);

    // `Foo&lt;String&gt;` is not assumed to be equal to `Foo&lt;char&gt;`.
    x = make_foo::&lt;char&gt;(44);
}
</code></pre></pre>
<h4 id="method-dispatch-and-trait-matching"><a class="header" href="#method-dispatch-and-trait-matching">Method dispatch and trait matching</a></h4>
<p>Given a method invocation <code>o.m(...)</code> where the method receiver <code>o</code> has opaque type <code>O&lt;P1...Pn&gt;</code>, methods defined in the opaque type's bounds are considered &quot;inherent methods&quot;, similar to a <code>dyn</code> receiver or a generic type.</p>
<p>Similarly, the compiler can assume that <code>O&lt;P1...Pn&gt;: Bi</code> is true for any of the declared bounds <code>Bi</code>.</p>
<p><strong>Example.</strong> The following program <strong>compiles</strong> because of this rule.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Foo = impl Clone;

fn clone_foo(f: Foo) -&gt; Foo {
    // Clone can be called without knowing the hidden type:
    f.clone()
}

fn make_foo() -&gt; Foo {
    // Hidden type constrained to be `u32`
    22_u32
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>Example.</strong> The following program <strong>does not compile</strong> even though the hidden type for <code>Foo</code> is known within <code>clone_foo</code>; this is because the type of <code>f</code> is <code>impl Clone</code> and we interpret that as a wish to only rely on the fact that <code>Foo: Clone</code> and nothing else (modulo auto trait leakage, see next rule).</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Foo = impl Clone;

fn clone_foo() {
    let f: Foo = 22_u32;

    // We don't know that `Foo: Debug`.
    debug!(&quot;{:?}&quot;, f);
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="rules-that-only-apply-outside-of-the-defining-scope-auto-trait-leakage"><a class="header" href="#rules-that-only-apply-outside-of-the-defining-scope-auto-trait-leakage">Rules that only apply outside of the defining scope: auto trait leakage</a></h3>
<p>The following type-checking rules can only be used when type-checking an item I that is <strong>not</strong> within the defining scope for the opaque type. When the type-checker for I wishes to employ one of these rules, it needs to &quot;fetch&quot; the hidden type for <code>O</code>. This may create a cycle in the computation graph if determining the hidden type for O requires type-checking the body of I (e.g., to compute the hidden type for another opaque type O1); cyclic cases result in a compilation error.</p>
<p><strong>Example.</strong> The following program <strong>compiles</strong> because of this rule:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Foo = impl Clone;

fn is_send&lt;T: Send&gt;() {}

fn clone_foo() {
    let f: Foo = 22_u32;

    // We can leak the hidden type of `u32` defined within this function.
    is_send::&lt;Foo&gt;();
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>Example.</strong> The following program <strong>does not compile</strong> because of a cycle:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn is_send&lt;T: Send&gt;() { }        

mod foo {
    pub type Foo = impl Clone;

    pub fn make_foo() -&gt; Foo {
        // Requires knowing hidden type of `Bar`:
        is_send::&lt;crate::bar::Bar&gt;();
        22_u32
    }
}

mod bar {
    pub type Bar = impl Clone;

    pub fn make_bar() -&gt; Foo {
        // Requires knowing hidden type of `Foo`:
        is_send::&lt;crate::foo::Foo&gt;();
        22_u32
    }
}
<span class="boring">}
</span></code></pre></pre>
<h4 id="auto-trait-leakage"><a class="header" href="#auto-trait-leakage">Auto trait leakage</a></h4>
<p>When proving <code>O&lt;P1...Pn&gt;: AT</code> for some auto trait <code>AT</code>, any item is permitted to use the hidden type <code>H</code> for <code>O&lt;P1...Pn&gt;</code> and show that <code>H: AT</code>.</p>
<h3 id="rules-that-only-apply-within-the-defining-scope-proposing-an-opaque-type"><a class="header" href="#rules-that-only-apply-within-the-defining-scope-proposing-an-opaque-type">Rules that only apply within the defining scope: proposing an opaque type</a></h3>
<p>The following type-checking rules can only be used when type-checking an item <code>I</code> that is within the defining scope for the opaque type <code>O</code>. If any of these rules are needed to type-check <code>I</code>, then <code>I</code> must compute a consistent type <code>H</code> to use as the hidden type for <code>O</code>. Any item <code>I</code> that relies on the rules in this section is said to <em>propose the hidden type <code>H</code> for the opaque type <code>O</code></em>. The process for inferring a hidden type is described below.</p>
<h4 id="equality-between-an-opaque-type-and-its-hidden-type"><a class="header" href="#equality-between-an-opaque-type-and-its-hidden-type">Equality between an opaque type and its hidden type</a></h4>
<p>An opaque type <code>O&lt;P0...Pn&gt;</code> can be judged to be equal to its hidden type <code>H</code>.</p>
<p><strong>Example.</strong> The following program <strong>compiles</strong> because of this rule:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Foo = impl Clone;

fn test() {
    // Requires that `Foo` be equal to the hidden type, `u32`.
    let x: Foo = 22_u32;
}
<span class="boring">}
</span></code></pre></pre>
<h4 id="auto-trait-leakage-1"><a class="header" href="#auto-trait-leakage-1">Auto trait leakage</a></h4>
<p>When proving <code>O&lt;P1...Pn&gt;: AT</code> for some auto trait <code>AT</code>, <code>I</code> can use the hidden type <code>H</code> to show that <code>H: AT</code>.</p>
<p><strong>Example.</strong> The following program <strong>compiles</strong> because of this rule:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Foo = impl Clone;

fn is_send&lt;T: Send&gt;() {}

fn test() {
    let x: Foo = 22_u32;
    is_send::&lt;Foo&gt;();
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>Example.</strong> The following program <strong>does not compile</strong>. This is because it requires this rule to compile, but does not actually constrain the hidden type in any other way.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Foo = impl Clone;

fn is_send&lt;T: Send&gt;() {}

fn test() {
    is_send::&lt;Foo&gt;();
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="determining-the-hidden-type"><a class="header" href="#determining-the-hidden-type">Determining the hidden type</a></h2>
<p>To determine the hidden type for some opaque type <code>O</code>, we examine the set <code>C</code> of items that propose a hidden type <code>O</code>. If that set is an empty set, there is a compilation error. If two items in the set propose distinct hidden types for <code>O</code>, that is also an error. Otherwise, if all items propose the same hidden type <code>H</code> for <code>O</code>, then <code>H</code> becomes the hidden type for <code>O</code>.</p>
<h3 id="computing-the-hidden-type-proposed-by-an-item-i"><a class="header" href="#computing-the-hidden-type-proposed-by-an-item-i">Computing the hidden type proposed by an item <code>I</code></a></h3>
<p>Computing the hidden type <code>H</code> for <code>O&lt;P1..Pn&gt;</code> that is required by the item <code>I</code> must be done independently from any other items within the defining scope of <code>O</code>. It can be done by creating an inference variable <code>?V</code> for <code>O&lt;P1..Pn&gt;</code> and unifying <code>?O</code> with all types that must be equal to <code>O&lt;P1...Pn&gt;</code>. This inference variable <code>?V</code> is called the <em>exemplar</em>, as it is an &quot;example&quot; of what the hidden type is when <code>P1..Pn</code> are substituted for the generic arguments of <code>O</code>. Note that a given function may produce multiple exemplars for a single opaque type if it contains multiple references to <code>O</code> with distinct generic arguments. Computing the actual hidden type is done by <a href="#higher-order-pattern-unification">higher-order pattern unification</a>. </p>
<h3 id="limitations-on-exemplars"><a class="header" href="#limitations-on-exemplars">Limitations on exemplars</a></h3>
<p>Whenever an item <code>I</code> proposes a hidden type, the following conditions must be met:</p>
<ul>
<li>All of the exemplars from a given item <code>I</code> must map to the same hidden type <code>H</code>.</li>
<li>Each exemplar type <code>E</code> must be completely constrained and must not involve unbound inference variables.</li>
</ul>
<h4 id="examples"><a class="header" href="#examples">Examples</a></h4>
<p>The following function has two exemplars but they both map to the same hidden type, so it is legal:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Foo&lt;T, U&gt; = impl Debug;

fn compatible&lt;A, B&gt;(a: A, b: B) {
    // Exemplar: (A, B) for Foo&lt;A, B&gt;
    // Hidden type: (T, U)
    let _: Foo&lt;A, B&gt; = (a, b);

    // Exemplar: (B, A) for Foo&lt;B, A&gt;
    // Hidden type: (T, U)
    let _: Foo&lt;B, A&gt; = (b, a);
}
<span class="boring">}
</span></code></pre></pre>
<p>The following program is illegal because of the restriction against having incompatible examplars.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Foo&lt;T, U&gt; = impl Debug;

fn incompatible&lt;A, B&gt;(a: A, b: B) {
    // Exemplar: (A, B)
    // Hidden type: (T, U)
    let _: Foo&lt;A, B&gt; = (a, b);

    // Exemplar: (B, A)
    // Hidden type: (U, T)
    let _: Foo&lt;A, B&gt; = (b, a);
}
<span class="boring">}
</span></code></pre></pre>
<p>The following program is illegal because of the restriction against having incomplete types. This is true even though the two functions, taken in aggregate, have enough information to compute the hidden type for <code>Foo</code>.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Foo = impl Debug;

fn incomplete1() {
    // Computes an incomplete exemplar of `Result&lt;(), _&gt;`.
    let x: Foo = Ok(());
}

fn incomplete2() {
    // Computes an incomplete exemplar of `Result&lt;_, ()&gt;`.
    let x: Foo = Err(());
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="higher-order-pattern-unification"><a class="header" href="#higher-order-pattern-unification">Higher-order pattern unification</a></h3>
<p>When an item <code>I</code> finishes its type check, it will have computed an exemplar type <code>E</code> for the opaque type <code>O&lt;P1..Pn&gt;</code>. This must be mapped back to the hidden type <code>H</code>. Thanks to the <a href="./tait_generics.html">limitations on type alias generic parameters</a>, this can be done by a process called <em>higher-order pattern unification</em> (a limited, tractable form of <em>higher-order unification</em>). Higher-order pattern unification is best explained by example.</p>
<p>Consider an opaque type <code>Foo</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>type Foo&lt;T, U&gt; = impl Clone;
<span class="boring">}
</span></code></pre></pre>
<p>and an item <code>make_foo</code> that contains <code>Foo</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn make_foo&lt;X: Clone, Y: Clone&gt;(x: X, y: Y) -&gt; Foo&lt;X, Y&gt; {
    vec![(x, y)]
}
<span class="boring">}
</span></code></pre></pre>
<p>Here the opaque type <code>O&lt;P1, P2&gt;</code> is <code>Foo&lt;X, Y&gt;</code> (i.e., <code>P1</code> is <code>X</code> and <code>P2</code> is <code>Y</code>) and the exemplar type <code>E</code> is <code>Vec&lt;(X, Y)&gt;</code>. We wish to compute the <em>hidden</em> type, which will be <code>Vec&lt;(T, U)&gt;</code> -- note that the hidden type references the generics from the declaration of <code>Foo</code>, whereas the exemplar references the generics from <code>make_foo</code>. Computing the hidden type can be done by finding each occurence of a generic argument <code>Pi</code> (in this case, <code>X</code> and <code>Y</code>) and mapping to the corresponding generic parameter <code>i</code> from the opaque type declaration (in this case, <code>T</code> and <code>U</code> respectively).</p>
<p>This process is well-defined because of the <a href="./tait_generics.html">limitations on type alias generic parameters</a>. Thanks to those limitations, we know that:</p>
<ul>
<li>each generic argument <code>Pi</code> will be some generic type on <code>make_foo</code>;</li>
<li>each generic argument <code>Pi</code> to the opaque type will be distinct from each other argument <code>Pj</code>.</li>
</ul>
<p>In particular, these limitations mean that whenever we see an instance of some parameter <code>Pi</code> in the exemplar, the only way that <code>Pi</code> could appear in the final hidden type is if it was introduced by substitution for one of the generic arguments.</p>
<p>To see the ambiguity that is introduced without these limitations, consider what would mappen if you had a function like <code>bad_make_foo1</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn bad_make_foo1() -&gt; Foo&lt;u32, i32&gt; {
    vec![(22_u32, 22_i32)]
}
<span class="boring">}
</span></code></pre></pre>
<p>Here the exemplar type is <code>Vec&lt;(u32, i32)&gt;</code>, but the hidden type is ambiguous. It could be <code>Vec&lt;(T, U)&gt;</code>, as before, but it could also just be <code>Vec&lt;(u32, i32)&gt;</code>. The problem is that this example violates the first restriction: the parameters <code>u32</code> and <code>i32</code> are not generics on <code>bad_make_foo1</code>. This means that they are types which can be named from both the definition of <code>type Foo</code> <em>and</em> from within the scope of <code>bad_make_foo1</code>, introducing ambiguity. </p>
<p>A similar problem happens when type parameters are repeated, as illustrated by <code>bad_make_foo2</code>:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn bad_make_foo2&lt;X: Clone&gt;(x: X) -&gt; Foo&lt;X, X&gt; {
    vec![(x.clone(), x.clone())]
}
<span class="boring">}
</span></code></pre></pre>
<p>The exemplar type here is <code>Vec&lt;(X, X)&gt;</code>. The hidden type, however, could either be <code>Vec&lt;(T, T)&gt;</code> or <code>Vec&lt;(T, U)&gt;</code> or <code>Vec&lt;(U, U)&gt;</code>. All of them would be the same after substitution.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../explainer/auto_trait.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                            <a rel="next" href="../explainer/where_ok.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../explainer/auto_trait.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                    <a rel="next" href="../explainer/where_ok.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
    </body>
</html>
